<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Title of the document</title>
    <style type="text/css">
        #states>path:hover {
            fill-opacity: .7;
        }
        svg {
            font-family: "Helvetica Neue", Helvetica;
        }

        .line {
            fill: none;
            stroke: #000;
            stroke-width: 2px;
        }

        body {
            font: 10px sans-serif;
        }

        .axis path,
        .axis line,
        .axis1 path,
        .axis1 line {
            fill: none;
            stroke: #E6E7E8;
            shape-rendering: crispEdges;
        }

        .x.axis path,
        .x.axis1 path {
            display: none;
        }

        .line {
            fill: none;
            stroke-width: 1.5px;
        }

        .legend-box {
            cursor: pointer;
            margin-bottom: 2px;
        }
        text{

            font-size:11px
        }
        #mouse-tracker {
            stroke: #E6E7E8;
            stroke-width: 1px;
        }

        .hover-line {
            stroke: #E6E7E8;
            fill: none;
            stroke-width: 1px;
            left: 10px;
            shape-rendering: crispEdges;
            opacity: 1e-6;
        }

        .hover-text {
            stroke: none;
            font-size: 30px;
            font-weight: bold;
            fill: #000000;
        }

        .tooltip {
            font-weight: normal;
        }

        .brush .extent {
            stroke: #FFF;
            shape-rendering: crispEdges;
        }
        .background {
            fill: none;
            pointer-events: all;
        }

        #states {
            fill: #aaa;
        }

        #states .active {
            fill: orange;
        }

        #state-borders {
            fill: none;
            stroke: #fff;
            stroke-width: 1.5px;
            stroke-linejoin: round;
            stroke-linecap: round;
            pointer-events: none;
        }
    </style>
</head>

<body>

<div class="row">
    <!--Map Section-->
    <div class="col-md-4 mapframe">
    </div>
    <!--TimeSeries Section-->
    <div class="col-md-8 plotframe">
    </div>
</div>



<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<link rel="stylesheet" href="css/bootstrap.min.css">
<script src="js/bootstrap.min.js"></script>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="https://www.atlasestateagents.co.uk/javascript/tether.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>
<script type="text/javascript">//

//
var allStatesData=[];
var states;
var map_states;
var margin = {
            top: 20,
            right: 200,
            bottom: 100,
            left: 50
        },
margin2 = {
            top: 430,
            right: 10,
            bottom: 20,
            left: 40
        },
        width = $(".plotframe").width() - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom,
        height2 = 500 - margin2.top - margin2.bottom;


// Set the ranges
var x = d3.time.scale().range([0, width]);
var y = d3.scale.linear().range([height, 0]);
// 40 Custom DDV colors
var color = d3.scale.ordinal().range(["#48A36D", "#56AE7C", "#64B98C", "#72C39B", "#80CEAA", "#80CCB3", "#7FC9BD", "#7FC7C6", "#7EC4CF", "#7FBBCF", "#7FB1CF", "#80A8CE", "#809ECE", "#8897CE", "#8F90CD", "#9788CD", "#9E81CC", "#AA81C5", "#B681BE", "#C280B7", "#CE80B0", "#D3779F", "#D76D8F", "#DC647E", "#E05A6D", "#E16167", "#E26962", "#E2705C", "#E37756", "#E38457", "#E39158", "#E29D58", "#E2AA59", "#E0B15B", "#DFB95C", "#DDC05E", "#DBC75F", "#E3CF6D", "#EAD67C", "#F2DE8A"]);


var xScale2 = d3.time.scale()
        .range([0, width]); // Duplicate xScale for brushing ref later

// Define the axes
var xAxis = d3.svg.axis().scale(x)
        .orient("bottom").ticks(10);
var xAxis2 = d3.svg.axis() // xAxis for brush slider
        .scale(xScale2)
        .orient("bottom");
var yAxis = d3.svg.axis().scale(y)
        .orient("left").ticks(4);


// Define the line
var line = d3.svg.line()
        .interpolate("basis")
        .x(function(d) {
            return x(d.date);
        })
        .y(function(d) {
            return y(d.currentunemrate);
        })


// Append the time series svg canvas
var svg = d3.select(".plotframe").append("svg")
        .attr("width", "100%")
        .attr("height", height + margin.top + margin.bottom) //height + margin.top + margin.bottom
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


// Create invisible rect for mouse tracking
svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("x", 0)
        .attr("y", 0)
        .attr("id", "mouse-tracker")
        .style("fill", "white");

//append clip path for lines plotted, hiding those part out of bounds
svg.append("defs")
        .append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);
d3.tsv("statecodes.tsv", function(data) {
    states = data;
});


var finaldata = {
    seriesrecord: []
};
var parse = d3.time.format("%m %Y").parse;
var state;
var startYear;
startYear=parse("01 2014");
var endYear;
endYear=parse("12 2014");
//
d3.tsv("UE_AllStates.tsv", function(data) {


    data.forEach(function(d) {
        var series = d.series_id.trim();
        if (d.period != "M13" && series.substr(18, 2) == "03") {
            finaldata.seriesrecord.push({

                "state_code": series.substr(5, 2),
                "state": getState(series),
                "date": parse(d.period.substr(1) + " " + d.year),
                "currentunemrate": +d.value,
                "visible": false
            });
        }

    });

     allStatesData = d3.nest()
                .key(function(d) {
                return d.state;
                }).sortKeys(d3.ascending)
                .entries(finaldata.seriesrecord);
    console.log("series");
 for(var i=0;i<allStatesData.length;i++){
     console.log(i+""+ allStatesData[i].key)
 }
   /* for(var index=0;index<tempData.length;index++){
        if(allStatesData[tempData[index].key]==undefined)
            allStatesData[tempData[index].key]=[];
        allStatesData[tempData[index].key]= tempData[index].values;

    }*/
   // debugger;
    // Scale the range of the data
    // x.domain(d3.extent(finaldata.seriesrecord, function(d) {
    // return d.date;
    //}));
    x.domain([parse("01 2014"), parse("12 2014")]);
    //   y.domain([
    //     d3.min(symbols, function(c) { return d3.min(c.values, function(d) { return d.currentunemrate; }); }),
    // d3.max(symbols, function(c) { return d3.max(c.values, function(d) { return d.currentunemrate; }); })
    // ]);
    y.domain([
        0, 10
    ]);
    // color.domain(symbols.map(function(d){return d.key}));
    console.log(allStatesData);
     state = svg.selectAll(".state")
            .data(allStatesData) // Select nested data and append to new svg group elements
            .enter().append("g")
            .attr("class", "state");
    state.append("path")
            .attr("class", "line")
            .style("pointer-events", "none") // Stop line interferring with cursor
            .attr("clip-path", "url(#clip)") //use clip path to make irrelevant part invisible
            .style("stroke", function(d) {
                return color(d.key);
            })
            .attr("clip-path", "url(#clip)"); //use clip path to make irrelevant part invisible;
    tg=state.append("g")
            .attr("class","tg");

    tg.selectAll("text")
            .append("text")
            .data(function(d)
            {
                return d.values;
            })
            .enter().append("text")
            .attr("class","dots")
            .text(function(d){
                return d.currentunemrate
            })
            .attr("clip-path", "url(#clip)") //use clip path to make irrelevant part invisible
        /*    .attr("x", function(d) {
              //  console.log(d.date);

                return x(d.date) // If d.visible is true then draw line for this d selection
            })
            .attr("y", function(d) {
                // console.log(d.key);

                return y(d.currentunemrate) // If d.visible is true then draw line for this d selection
            })*/

    // draw legend
    var legendSpace = 450 / allStatesData.length; // 450/number of issues (ex. 40)

    state.append("rect")
            .attr("width", 10)
            .attr("height", 10)
            .attr("x", width + (margin.right / 3) - 15)
            .attr("y", function(d, i) {
                return (legendSpace) + i *1* (legendSpace) - 8;
            }) // spacing
            .attr("fill", function(d) {
                return d.visible ? color(d.key) : "#F1F1F2"; // If array key "visible" = true then color rect, if not then make it grey
            })
            .attr("class", "legend-box")

            .on("click", function(d) { // On click make d.visible
                d.visible = !d.visible; // If array key for this data selection is "visible" = true then make it false, if false then make it true

                // maxY = findMaxY(categories); // Find max Y rating value categories data with "visible"; true
                // yScale.domain([0,maxY]); // Redefine yAxis domain based on highest y value of categories data with "visible"; true
                // svg.select(".y.axis")
                //  .transition()
                //  .call(yAxis);
                maxY = findMaxY(allStatesData,startYear,endYear); // Find max Y rating value categories data with "visible"; true
                minY = findMinY(allStatesData,startYear,endYear); // Find max Y rating value categories data with "visible"; true
                console.log(minY);
                console.log(maxY);
                y.domain([minY, maxY]); // Redefine yAxis domain based on highest y value of categories data with "visible"; true
                svg.select(".y.axis")
                        .transition()
                        .call(yAxis);
                state.select("path")
                        .transition()
                        .attr("d", function(d) {
                            // console.log(d.key);

                            return d.visible ? line(d.values) : null; // If d.visible is true then draw line for this d selection
                        })

                state.select("rect")
                        .transition()
                        .attr("fill", function(d) {
                            return d.visible ? color(d.key) : "#F1F1F2";
                        });
            })
            state.append("text")
                    .attr("x", width + (margin.right / 3))
                    .attr("y", function(d, i) {
                        return (legendSpace) + i*1 * (legendSpace);
                    }) // (return (11.25/2 =) 5.625) + i * (5.625)
                    .text(function(d) {
                        return d.key;
                    });

    // Add the X Axis
    svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

    // Add the Y Axis
    svg.append("g")
            .attr("class", "y axis")
            .call(yAxis);
});

var mapWidth = 560, mapHeight = 500, centered;

var projection = albersUsaPr()
        .scale(500)
        .translate([mapWidth / 2, mapHeight / 2]);

var mappath = d3.geo.path()
        .projection(projection);

var mapsvg = d3.select(".mapframe").append("svg")
        .attr("width", mapWidth)
        .attr("height", mapHeight);

mapsvg.append("rect")
        .attr("class", "background")
        .attr("Width", mapWidth)
        .attr("Height", mapHeight)
        .on("click", clicked);

var mapg = mapsvg.append("g");

d3.json("usstates.json", function(error, us) {
    if (error) throw error;
    console.log( us);

    s=-1;
    map_states=mapg.append("g")
            .attr("id", "states")
            .selectAll("path")
            .data(topojson.feature(us, us.objects.states).features)
            .enter().append("path")
            .attr('test',function(d,i){

                 d.stateid=++s;
                d.active=false;
                if(d.id==42)
                    ++s;
            })
            .attr("d", mappath)
            .on("click", clicked);
    for(var i=0;i<topojson.feature(us, us.objects.states).features[i].length;i++){
        console.log( topojson.feature(us, us.objects.states).features[i].stateid+""+ topojson.feature(us, us.objects.states).features[i].properties.name);
    }
    mapg.append("path")
            .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
            .attr("id", "state-borders")
            .attr("d", mappath);
});

function clicked(d) {

    var index=d.stateid;
    if(index==52){
        index=39;
    }
    d.active=!d.active;
    allStatesData[index].visible=!allStatesData[index].visible;
    console.log(index+" "+d.stateid);
    console.log(allStatesData[index].key);
    //d.visible = !d.visible; // If array key for this data selection is "visible" = true then make it false, if false then make it true

    // maxY = findMaxY(categories); // Find max Y rating value categories data with "visible"; true
    // yScale.domain([0,maxY]); // Redefine yAxis domain based on highest y value of categories data with "visible"; true
    // svg.select(".y.axis")
    //  .transition()
    //  .call(yAxis);
    maxY = findMaxY(allStatesData,startYear,endYear); // Find max Y rating value categories data with "visible"; true
    minY = findMinY(allStatesData,startYear,endYear); // Find max Y rating value categories data with "visible"; true
    y.domain([minY, maxY]); // Redefine yAxis domain based on highest y value of categories data with "visible"; true
    svg.select(".y.axis")
            .transition()
            .call(yAxis);
    state.select("path")
            .transition()
            .attr("d", function(d) {
                // console.log(d.key);

                return d.visible ? line(d.values) : null; // If d.visible is true then draw line for this d selection
            })
    debugger
var v=false
    var temp=state.filter(function (d) {
                v=d.visible;
                  return d.visible;
                });
    var temp2=state.filter(function (d) {

        return d.visible==false;
    });
               temp.select(".tg")
            .selectAll("text")
                        .attr("x", function (d) {
                            //  console.log(d.date);

                            return x(d.date) // If d.visible is true then draw line for this d selection
                        })
                        .attr("y", function (d) {
                            // console.log(d.key);

                            return y(d.currentunemrate) // If d.visible is true then draw line for this d selection
                        })
    temp2.select(".tg")
            .selectAll("text")
            .attr("x", function (d) {
                //  console.log(d.date);

                return null // If d.visible is true then draw line for this d selection
            })
            .attr("y", function (d) {
                // console.log(d.key);

                return null // If d.visible is true then draw line for this d selection
            })

    state.select("rect")
            .transition()
            .attr("fill", function(d) {
                console.log(d.key+" "+d.visible);
                return d.visible ? color(d.key) : "#F1F1F2";
            });
   // console.log(map_states.select("path"))
    mapg.selectAll("path")
            .transition()
            .attr("fill", function(d2) {

                if(d2.active==true) {
                    return color(allStatesData[d2.stateid].key);
                }
                else
                {
                return "grey";
                }
            });


}


function getState(seriesid) {
    var code = seriesid.substr(5, 2);
    for (var i = 0; i < states.length; i++) {
        if (states[i].srd_code == code) {
            return states[i].srd_text;
        }
    }
}

function findMaxY(data,startYear,endYear) { // Define function "findMaxY"
    var maxYValues = data.map(function(d) {
        if (d.visible) {
            var val=[];
            for(var i=0;i<d.values.length;i++){
                if(d.values[i].date>=startYear && d.values[i].date<=endYear)
                    val.push(d.values[i]);
            }

            return d3.max(val, function(value) { // Return max rating value
                return value.currentunemrate;
            })
        }
    });
    return d3.max(maxYValues);
}
function findMinY(data,startYear,endYear) { // Define function "findMaxY"


    var minYValues = data.map(function(d) {
        if (d.visible) {
            var val=[];
            for(var i=0;i<d.values.length;i++){
                if(d.values[i].date>=startYear && d.values[i].date<=endYear)
                    val.push(d.values[i]);
            }
            return d3.min(val, function(value) { // Return max rating value
                return value.currentunemrate;
            })
        }
    });
    return d3.min(minYValues);
}
// A modified d3.geo.albersUsa to include Puerto Rico.
function albersUsaPr() {
    var ε = 1e-6;

    var lower48 = d3.geo.albers();

    // EPSG:3338
    var alaska = d3.geo.conicEqualArea()
            .rotate([154, 0])
            .center([-2, 58.5])
            .parallels([55, 65]);

    // ESRI:102007
    var hawaii = d3.geo.conicEqualArea()
            .rotate([157, 0])
            .center([-3, 19.9])
            .parallels([8, 18]);

    // XXX? You should check that this is a standard PR projection!
    var puertoRico = d3.geo.conicEqualArea()
            .rotate([66, 0])
            .center([0, 18])
            .parallels([8, 18]);

    var point,
            pointStream = {point: function(x, y) { point = [x, y]; }},
            lower48Point,
            alaskaPoint,
            hawaiiPoint,
            puertoRicoPoint;

    function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        point = null;
        (lower48Point(x, y), point)
        || (alaskaPoint(x, y), point)
        || (hawaiiPoint(x, y), point)
        || (puertoRicoPoint(x, y), point);
        return point;
    }

    albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
                t = lower48.translate(),
                x = (coordinates[0] - t[0]) / k,
                y = (coordinates[1] - t[1]) / k;
        return (y >= .120 && y < .234 && x >= -.425 && x < -.214 ? alaska
                : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii
                : y >= .204 && y < .234 && x >= .320 && x < .380 ? puertoRico
                : lower48).invert(coordinates);
    };

    // A naïve multi-projection stream.
    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    albersUsa.stream = function(stream) {
        var lower48Stream = lower48.stream(stream),
                alaskaStream = alaska.stream(stream),
                hawaiiStream = hawaii.stream(stream),
                puertoRicoStream = puertoRico.stream(stream);
        return {
            point: function(x, y) {
                lower48Stream.point(x, y);
                alaskaStream.point(x, y);
                hawaiiStream.point(x, y);
                puertoRicoStream.point(x, y);
            },
            sphere: function() {
                lower48Stream.sphere();
                alaskaStream.sphere();
                hawaiiStream.sphere();
                puertoRicoStream.sphere();
            },
            lineStart: function() {
                lower48Stream.lineStart();
                alaskaStream.lineStart();
                hawaiiStream.lineStart();
                puertoRicoStream.lineStart();
            },
            lineEnd: function() {
                lower48Stream.lineEnd();
                alaskaStream.lineEnd();
                hawaiiStream.lineEnd();
                puertoRicoStream.lineEnd();
            },
            polygonStart: function() {
                lower48Stream.polygonStart();
                alaskaStream.polygonStart();
                hawaiiStream.polygonStart();
                puertoRicoStream.polygonStart();
            },
            polygonEnd: function() {
                lower48Stream.polygonEnd();
                alaskaStream.polygonEnd();
                hawaiiStream.polygonEnd();
                puertoRicoStream.polygonEnd();
            }
        };
    };

    albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_);
        alaska.precision(_);
        hawaii.precision(_);
        puertoRico.precision(_);
        return albersUsa;
    };

    albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_);
        alaska.scale(_ * .35);
        hawaii.scale(_);
        puertoRico.scale(_);
        return albersUsa.translate(lower48.translate());
    };

    albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
                .translate(_)
                .clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]])
                .stream(pointStream).point;

        alaskaPoint = alaska
                .translate([x - .307 * k, y + .201 * k])
                .clipExtent([[x - .425 * k + ε, y + .120 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]])
                .stream(pointStream).point;

        hawaiiPoint = hawaii
                .translate([x - .205 * k, y + .212 * k])
                .clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]])
                .stream(pointStream).point;

        puertoRicoPoint = puertoRico
                .translate([x + .350 * k, y + .224 * k])
                .clipExtent([[x + .320 * k, y + .204 * k], [x + .380 * k, y + .234 * k]])
                .stream(pointStream).point;

        return albersUsa;
    };

    return albersUsa.scale(1070);
}
</script>
</body>



</html>